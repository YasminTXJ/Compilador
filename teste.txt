#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_LINE 1024
#define KB 1024
#define DEFAULT_MEMORY_LIMIT (2048 * KB)

// Variáveis globais
char ultimo_tipo[20] = "";
char ultima_variavel[50] = "";
char escopo_atual[50] = "global";
char escopo_anterior[50] = "global";
char tipo_token_anterior[50] = "";
int dentro_funcao = 0;
int chaves_dentro_funcao = 0;
size_t total_memory_used = 0;
size_t max_memory_used = 0;
size_t memory_limit = DEFAULT_MEMORY_LIMIT;

// Alocação de memória
void *safe_malloc(size_t size) {
  if (total_memory_used + size > memory_limit) {
    fprintf(stderr, "ERRO: Memória Insuficiente\n");
    exit(EXIT_FAILURE);
  }

  void *ptr = malloc(size);
  if (!ptr) {
    fprintf(stderr, "ERRO: Falha na alocação\n");
    exit(EXIT_FAILURE);
  }

  total_memory_used += size;
  if (total_memory_used > max_memory_used) {
    max_memory_used = total_memory_used;
  }

  return ptr;
}

void safe_free(void *ptr, size_t size) {
  if (ptr) {
    free(ptr);
    if (total_memory_used >= size) {
      total_memory_used -= size;
    }
  }
}

// Estrutura da tabela de símbolos
typedef struct Simbolo {
  char tipo[20];
  char nome[50];
  char valor[100];
  char escopo[50];
  struct Simbolo *prox;
} Simbolo;
Simbolo *tabela_simbolos = NULL;

// Função para buscar símbolo
Simbolo *buscarSimbolo(const char *nome, const char *escopo) {
  Simbolo *atual = tabela_simbolos;
  while (atual != NULL) {
    if (strcmp(atual->nome, nome) == 0 && strcmp(atual->escopo, escopo) == 0) {
      return atual;
    }
    atual = atual->prox;
  }
  return NULL;
}

// Criar símbolo
Simbolo *criarSimbolo(const char *tipo, const char *nome, const char *valor,
                      const char *escopo) {
  Simbolo *novo = (Simbolo *)safe_malloc(sizeof(Simbolo));
  strcpy(novo->tipo, tipo);
  strcpy(novo->nome, nome);
  strcpy(novo->valor, valor);
  strcpy(novo->escopo, escopo);
  novo->prox = NULL;
  return novo;
}

// Adicionar símbolo
void adicionaSimbolo(const char *tipo, const char *nome, const char *valor,
                     const char *escopo) {
  Simbolo *novo = criarSimbolo(tipo, nome, valor, escopo);
  novo->prox = tabela_simbolos;
  tabela_simbolos = novo;
}

// Verificações de tokens
const char *keywords[] = {"principal", "funcao", "retorno", "leia",
                          "escreva",   "se",     "senao",   "para"};
const char *tipos[] = {"inteiro", "texto", "decimal"};
const char *operadores[] = {"==", "<>", "<=", ">=", "&&", "||", "+",
                            "-",  "*",  "/",  "^",  "<",  ">",  "="};

int isKeyword(const char *token) {
  for (int i = 0; i < sizeof(keywords) / sizeof(keywords[0]); i++) {
    if (strcmp(token, keywords[i]) == 0) return 1;
  }

  return 0;
}

int isTipo(const char *token) {
  for (int i = 0; i < sizeof(tipos) / sizeof(tipos[0]); i++) {
    if (strcmp(token, tipos[i]) == 0) return 1;
  }
  return 0;
}

int isOperador(const char *token) {
  for (int i = 0; i < sizeof(operadores) / sizeof(operadores[0]); i++) {
    if (strcmp(token, operadores[i]) == 0) return 1;
  }

  return 0;
}

int isVariavel(const char *token) {
  return token[0] == '!' && islower(token[1]);
}

int isFuncao(const char *token) {
  return strncmp(token, "__", 2) == 0 &&
         (isalpha(token[2]) || isdigit(token[2]));
}

int isNumero(const char *token) {
  int ponto = 0;
  for (int i = 0; token[i]; i++) {
    if (token[i] == '.') ponto++;
    else if (!isdigit(token[i])) return 0;
  }
  return ponto <= 1;
}

int verificaAsciiValido(char c) { return (c >= 0 && c <= 127); }

int tokenAsciiValido(const char *token) {
  for (int i = 0; token[i] != '\0'; i++) {
    if (token[i] < 0 || token[i] > 127) return 0;
  }
  return 1;
}

// Classificação e inserção de tokens
void classificaToken(const char *token, int linha) {
  if (strlen(token) == 0) return;


  if (isKeyword(token)) {
     strcpy(tipo_token_anterior, "keyword");
    if (strcmp(token, "principal") == 0) {
      strcpy(escopo_atual, token);
    }
  } else if (isTipo(token)) {
     strcpy(tipo_token_anterior, "tipo");
    strcpy(ultimo_tipo, token);
  } else if (isFuncao(token)) {
    strcpy(tipo_token_anterior, "funcao");
    strcpy(escopo_anterior, escopo_atual);
    strcpy(escopo_atual, token);
    dentro_funcao = 1;
  } else if (isVariavel(token)) {
    Simbolo *existente = buscarSimbolo(token, escopo_atual);
    if (strlen(ultimo_tipo) > 0) {
      /*if (existente) {
        printf("[LINHA %d] ERRO: Variável '%s' já declarada no escopo '%s'.\n", linha, token, escopo_atual);
      } else {*/
        adicionaSimbolo(ultimo_tipo, token, "", escopo_atual);
     // }
    } else {
      strcpy(ultima_variavel, token);
    }
  } else if (isNumero(token) || (token[0] == '"' && token[strlen(token) - 1] == '"')) {
    if (strlen(ultima_variavel) > 0) {
      Simbolo *var = buscarSimbolo(ultima_variavel, escopo_atual);
      if (var) {
        strcpy(var->valor, token);
      } else {
        printf("[LINHA %d] ERRO: Variável '%s' não declarada.\n", linha, ultima_variavel);
      }
      ultima_variavel[0] = '\0';
    }
  } else if (strcmp(token, "{") == 0) {
    if (dentro_funcao) chaves_dentro_funcao++;
  } else if (strcmp(token, "}") == 0) {
    if (dentro_funcao) {
      chaves_dentro_funcao--;
      if (chaves_dentro_funcao == 0) {
        strcpy(escopo_atual, "global");
        dentro_funcao = 0;
      }
    }
  }
}

// Tokenização de linha
void tokenizeLine(const char *line, int num_linha) {
  char token[256];
  int i = 0, j = 0;
  int len = strlen(line);
  int dentroDeString = 0;

  while (i < len) {
    char c = line[i];
    if (c == '"') dentroDeString = !dentroDeString;

    if (!dentroDeString && !verificaAsciiValido(c)) {
      printf("[LINHA %d] ERRO: Caractere inválido: %c (%d)\n", num_linha, c, c);
      i++;
      break;
    }

    switch (c) {
    case ' ':
    case '\t':
    case '\n':
      token[j] = '\0';
      classificaToken(token, num_linha);
      j = 0;
      i++;
      break;

    case '"':
      j = 0;
      token[j++] = line[i++];
      while (i < len && line[i] != '"') token[j++] = line[i++];
      if (i < len && line[i] == '"') token[j++] = line[i++];
      token[j] = '\0';
      classificaToken(token, num_linha);
      j = 0;
      break;

    case '!':
      token[j] = '\0';
      classificaToken(token, num_linha);
      j = 0;
      token[j++] = c;
      i++;
      while (i < len && isalnum(line[i])) token[j++] = line[i++];
      token[j] = '\0';
      classificaToken(token, num_linha);
      j = 0;
      break;

    case '=': case '<': case '>': case '&': case '|':
      token[j] = '\0';
      classificaToken(token, num_linha);
      j = 0;
      if ((c == '=' && line[i + 1] == '=') ||
          (c == '<' && (line[i + 1] == '=' || line[i + 1] == '>')) ||
          (c == '>' && line[i + 1] == '=') ||
          (c == '&' && line[i + 1] == '&') ||
          (c == '|' && line[i + 1] == '|')) {
        char op_duplo[3] = {c, line[i + 1], '\0'};
        classificaToken(op_duplo, num_linha);
        i += 2;
      } else {
        char op[2] = {c, '\0'};
        classificaToken(op, num_linha);
        i++;
      }
      break;

    case '+': case '-': case '*': case '/': case '^':
    case '(': case ')': case '{': case '}':
    case '[': case ']': case ';': case ',':
      token[j] = '\0';
      classificaToken(token, num_linha);
      j = 0;
      char simbolo[2] = {c, '\0'};
      classificaToken(simbolo, num_linha);
      i++;
      break;

    default:
      token[j++] = c;
      i++;
      break;
    }
  }
  token[j] = '\0';
  classificaToken(token, num_linha);
}

// Main
int main() {
  FILE *fp = fopen("Codigo2.txt", "r");
  if (!fp) {
    perror("Erro ao abrir o arquivo");
    return 1;
  }

  char *linha = (char *)safe_malloc(MAX_LINE);
  int num_linha = 1;

  while (fgets(linha, MAX_LINE, fp)) {
    tokenizeLine(linha, num_linha);
    num_linha++;
  }

  safe_free(linha, MAX_LINE);
  fclose(fp);

  printf("\n[TABELA DE SÍMBOLOS]\n");
  printf("%-15s %-15s %-15s %-15s\n", "Tipo", "Nome", "Valor", "Escopo");

  Simbolo *atual = tabela_simbolos;
  while (atual) {
    printf("%-15s %-15s %-15s %-15s\n",
           atual->tipo, atual->nome, atual->valor, atual->escopo);
    atual = atual->prox;
  }

  printf("\n[MEMÓRIA]\n");
  printf("Máximo de memória usada: %.2f KB\n", (float)max_memory_used / KB);
  printf("Memória total usada: %.2f KB\n", (float)total_memory_used / KB);

  return 0;
}
